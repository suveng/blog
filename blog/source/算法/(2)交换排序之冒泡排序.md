title:  (2)交换排序之冒泡排序
date: 2019-01-24 13:00:00 +0800
update: 2019-01-24 13:00:00 +0800
author: me
cover: http://ww1.sinaimg.cn/large/006jIRTegy1fzwiafdswej31jk0v9qp2.jpg
preview:  冒泡排序是非常好理解的，以从小到大排序为例，每一轮排序就找出未排序序列中最大值放在最后。
tags:

  -  算法

---



[TOC]

![封面图](http://ww1.sinaimg.cn/large/006jIRTegy1fzwiafdswej31jk0v9qp2.jpg)

# (2)交换排序之冒泡排序

## 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3. 针对所有的元素重复以上的步骤，除了最后一个。

4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

## 演示图

![演示图](http://ww1.sinaimg.cn/large/006jIRTegy1fzwgvy5j3bg30qk0eugzu.gif)

## 时间复杂度

平均: O(n^2)

最好: O(n)

最差: O(n^2)

## 空间复杂度

O(1)

## 稳定性

稳定

## Java代码实现

### (1) 没有任何优化

```java
class BubbleSortClass{
	public static void main(String[] args) {
		System.out.println("冒泡排序－没有优化的");
		int[] arr = {1,1,2,0,9,3,12,7,8,3,4,65,22};
		System.out.println("原数组");

		for(int i:arr){
			System.out.print(i+",");
		}

		BubbleSortClass.BubbleSort(arr);
		System.out.printf("\n排序后的\n");

		for(int i:arr){
			System.out.print(i+",");
		}
	}
	public static void BubbleSort(int[] arr){
		int i ,j;
		int n=arr.length;
		for(i=0;i<n-1;i++){
			for(j=1;j<n-i;j++){
				if(arr[j-1]>arr[j]){
					int temp=arr[j-1];
					arr[j-1]=arr[j];
					arr[j]=temp;
				}
			}
		}
	}
}
```



### (2) 对本身有排序的进行优化

### (3) 部分有序，部分无序

现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字





## 参考文章

[ＣＳＤＮ－u010853261](https://blog.csdn.net/u010853261/article/details/54891710)

## [我的主页](https://suveng.github.io/blog/)