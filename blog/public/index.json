[{"content":"\n\n#  joda-time使用教程\n\n## 介绍\n\n\u003e The Joda project provides quality low-level libraries for the Java platform.\n\u003e Joda项目为Java平台提供了高质量的低级库。https://www.joda.org/\n\u003e Joda-Time为Java日期和时间类提供了高质量的替代品。Joda-Time是Java SE 8之前Java的事实上*标准日期和时间库。现在要求用户迁移到`java.time`（JSR-310）。Joda-Time根据业务友好Apache 2.0许可证（https//www.joda.org/joda-time/licenses.html）获得许可。https://www.joda.org/joda-time/\n\u003e [官方文档-快速开始](https://www.joda.org/joda-time/quickstart.html)\n\n## 类总览\n\n* LocalDate  - 没有时间的日期\n* LocalTime  - 没有日期的时间\n* Instant - 时间线上的瞬时点\n* DateTime  - 带时区的完整日期和时间\n* DateTimeZone  - 一个更好的时区\n* Duration  - 时间量\n  Interval - 两个瞬间之间的时间\n\n## 环境\n\nIntelliJ IDEA 2018.2.7 (Ultimate Edition)\nJRE: 1.8.0_152-release-1248-b22 amd64\nJVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o\nWindows 10 10.0\n\n## 配置\n\n使用maven导包\n\n**注意**：jdk版本问题，这里选用依赖jdk1.5的版本，即2.3版，jdk1.8选用更高版本吧，因为jdk1.8的java.time 里面的api估摸着够用了。\n\n```xml\n\u003cdependency\u003e\n    \u003cgroupId\u003ejoda-time\u003c/groupId\u003e\n    \u003cartifactId\u003ejoda-time\u003c/artifactId\u003e\n    \u003cversion\u003e2.4\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n## 简单使用\n\n* String转换为joda-time\n\n```java\n @Test\n    public void testStrToJodaDate(){\n        DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(DATETIME_PATTERN);\n\n        DateTime parse = DateTime.parse(\"2018-12-11 17:06:30\", dateTimeFormatter);\n\n        System.out.println(parse);\n    }\n```\n\n* date 转 joda-time\n\n```java\n@Test\n    public void testDateToJodaDate(){\n        Date date = new Date();\n\n        DateTime dateTime = new DateTime(date);\n\n        System.out.println(dateTime);\n\n    }\n```\n\n* calendar 转 joda-time\n\n```java\n@Test\n    public void testCalendarToJodaDate(){\n        Calendar instance = Calendar.getInstance();\n\n        DateTime dateTime = new DateTime(instance);\n\n        System.out.println(dateTime);\n    }\n```\n\n* string 转 date\n\n```java\n@Test\n    public void testStrToDate(){\n        DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(DATE_PATTERN);\n\n        String str=\"2018-12-07\";\n\n        DateTime parse = DateTime.parse(str, dateTimeFormatter);\n\n        Date date = parse.toDate();\n\n        System.out.println(date);\n\n    }\n```\n\n* joda 转 calendar\n\n```java\n@Test\n    public void testJodaToCalendar(){\n        DateTime dateTime = new DateTime(new Date());\n\n        Calendar calendar = dateTime.toCalendar(Locale.CHINA);\n        System.out.println(calendar);\n    }\n```\n\n* joda 转 str\n\n```java\n    @Test\n    public void testJodaToStr(){\n        DateTime dateTime = new DateTime();\n        String string = dateTime.toString(TIME_PATTERN);\n        String string2 = dateTime.toString(TIME_PATTERN,Locale.CHINA);\n        System.out.println(string+string2);\n    }\n```\n\n* date 转 str\n\n```java\n    @Test\n    public void testDateToStr(){\n        Date date = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATETIME_PATTERN);\n        String format = simpleDateFormat.format(date);\n        System.out.println(format);\n    }\n```","cover":"images/wallhaven-714079.jpg","link":"joda-time使用教程.html","preview":"\u003cp\u003eJoda项目为Java平台提供了高质量的低级库。Joda-Time为Java日期和时间类提供了高质量的替代品\u003c/p\u003e\n","title":"joda-time使用教程"},{"content":"\r\n\r\n# 插入排序之直接插入排序\r\n\r\n## 原理\r\n\r\n1. 列表第一个元素和前面元素比较，如果小于前面元素（其实不存在），则交换位置。（这步其实可以没有）\r\n2. 列表第二个元素和前面元素（第一个元素）比较，如果小于前面元素，则交换位置。\r\n3. 列表第三个元素和前面元素（第二个元素）比较，如果小于前面元素，则交换位置。如果和前面元素交换了位置，现在在第二个位置上，则接着继续和前面元素比较（第一个元素），如果小于前面元素，接着再次交换位置，然后再次重复比较过程....\r\n4. 继续重复以上过程，直到最后一个元素完成比较\r\n\r\n![直接插入排序演示](http://piezqhqs4.bkt.clouddn.com/直接插入排序演示.gif)\r\n\r\n\r\n\r\n## 时间复杂度\r\n\r\n| 最坏时间复杂度 | 最优时间复杂度 | 平均时间复杂度 |\r\n| :------------: | :------------: | :------------: |\r\n|     O(n^2)     |      O(n)      |     O(n^2)     |\r\n\r\n## 空间复杂度\r\n\r\nO(1)\r\n\r\n## 稳定性\r\n\r\n**稳定**\r\n\r\n\u003e **稳定性定义：**排序前后两个相等的数相对位置不变，则算法稳定。\r\n\r\n## 算法实现\r\n\r\n### Java\r\n\r\n```java\r\nclass InsertionSort {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println(\"hello，直接插入排序\");\r\n\t\tInsertSort is=new InsertSort();\r\n\t\tint[] des=is.directInsertSort(new int[]{72,78,42,60,84,74,60,79,72,52});\r\n\t\tfor(int i=0;i\u003cdes.length;i++){\r\n\t\t\tSystem.out.println(\" \"+des[i]);\r\n\t\t}\r\n\t\tSystem.out.println();\r\n\t}\r\n\t\r\n\tpublic int[] directInsertSort(int[] source){\r\n\t\tint n=source.length;\r\n\t\t//可以直接从第二个元素开始\r\n\t\tfor(int i=1;i\u003cn;i++){\r\n\t\t\tfor(int j=i;j\u003e0;j--){\r\n\t\t\t\tif(source[j]\u003csource[j-1]){\r\n\t\t\t\t\t//异或法 交换变量，减少临时变量\r\n\t\t\t\t\tsource[j]=source[j]^source[j-1];\r\n\t\t\t\t\tsource[j-1]=source[j]^source[j-1];\r\n\t\t\t\t\tsource[j]=source[j]^source[j-1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn source;\r\n\t}\r\n}\r\n```\r\n\r\n","cover":"images/wallhaven-718249.jpg","link":"插入排序之直接插入排序.html","preview":"","title":"插入排序之直接插入排序"}]